package leetcode.practice_easy;

/**
 * 数组练习模板
 */
public class ArrayPracticeTpl {

    /**
     * leetCode.26
     * 用原地算法删除数组 nums 中重复出现的元素, 返回删除后数组的新长度
     * <p>
     * 输入: nums = [1,1,2]
     * 输出: 2, nums = [1,2]
     * <p>
     * 输入: nums = [0,0,1,1,1,2,2,3,3,4]
     * 输出: 5, nums = [0,1,2,3,4]
     */
    public int removeDuplicates(int[] nums) {
        return 0;
    }

    /**
     * leetCode.122
     * 买卖股票的最佳时机
     * <p>
     * 输入: prices = [7,1,5,3,6,4]
     * 输出: 7
     * <p>
     * 输入: prices = [1,2,3,4,5]
     * 输出: 4
     */
    public int maxProfit(int[] prices) {
        return 0;
    }

    /**
     * leetCode.189
     * 给定一个数组, 将数组中的元素向右移动 k 个位置, 其中 k 是非负数
     * <p>
     * 输入: nums = [1,2,3,4,5,6,7], k = 3
     * 输出: [5,6,7,1,2,3,4]
     * <p>
     * 输入: nums = [-1,-100,3,99], k = 2
     * 输出: [3,99,-1,-100]
     */
    public void rotate(int[] nums, int k) {

    }

    /**
     * leetCode.217
     * 给定一个整数数组, 判断是否存在重复元素
     * <p>
     * 输入: [1,2,3,1]
     * 输出: true
     * <p>
     * 输入: [1,2,3,4]
     * 输出: false
     */
    public boolean containsDuplicate(int[] nums) {
        return false;
    }

    /**
     * leetCode.136
     * 给定一个非空整数数组, 除了某个元素只出现一次以外, 其余每个元素均出现两次. 找出那个只出现了一次的元素
     * <p>
     * 输入: [2,2,1]
     * 输出: 1
     * <p>
     * 输入: [4,1,2,1,2]
     * 输出: 4
     */
    public int singleNumber(int[] nums) {
        return 0;
    }

    /**
     * leetCode.350
     * 给定两个数组, 编写一个函数来计算它们的交集
     * <p>
     * 输入: nums1 = [1,2,2,1], nums2 = [2,2]
     * 输出: [2,2]
     * <p>
     * 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
     * 输出: [4,9]
     */
    public int[] intersect(int[] nums1, int[] nums2) {
        return null;
    }

    /**
     * leetCode.66
     * 给定一个由整数组成的 非空数组所表示的非负整数, 在该数的基础上加一
     * <p>
     * 输入: digits = [1,2,3]
     * 输出: [1,2,4]
     * <p>
     * 输入: digits = [4,3,2,1]
     * 输出: [4,3,2,2]
     */
    public int[] plusOne(int[] digits) {
        return null;
    }

    /**
     * leetCode.283
     * 给定一个数组 nums, 编写一个函数将所有 0 移动到数组的末尾, 同时保持非零元素的相对顺序
     * <p>
     * 输入: [0,1,0,3,12]
     * 输出: [1,3,12,0,0]
     */
    public void moveZeroes(int[] nums) {

    }

    /**
     * leetCode.1
     * 给定一个整数数组 nums 和一个整数目标值 target, 请你在该数组中找出和为目标值 target 的那两个整数, 并返回它们的数组下标
     * <p>
     * 输入: nums = [2,7,11,15], target = 9
     * 输出: [0,1]
     * <p>
     * 输入: nums = [3,2,4], target = 6
     * 输出: [1,2]
     */
    public int[] twoSum(int[] nums, int target) {
        return null;
    }

    /**
     * leetCode.36
     * 请你判断一个 9x9 的数独是否有效
     * 数字 1-9 在每一行只能出现一次.
     * 数字 1-9 在每一列只能出现一次.
     * 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次
     * <p>
     * 输入: board = [
     * ["5","3",".",  ".","7",".",  ".",".","."],
     * ["6",".",".",  "1","9","5",  ".",".","."],
     * [".","9","8",  ".",".",".",  ".","6","."],
     * <p>
     * ["8",".",".",  ".","6",".",  ".",".","3"],
     * ["4",".",".",  "8",".","3",  ".",".","1"],
     * ["7",".",".",  ".","2",".",  ".",".","6"],
     * <p>
     * [".","6",".",  ".",".",".",  "2","8","."],
     * [".",".",".",  "4","1","9",  ".",".","5"],
     * [".",".",".",  ".","8",".",  ".","7","9"],
     * ]
     * 输出: true
     * <p>
     * 输入: board = [
     * ["8","3",".",  ".","7",".",  ".",".","."],
     * ["6",".",".",  "1","9","5",  ".",".","."],
     * [".","9","8",  ".",".",".",  ".","6","."],
     * <p>
     * ["8",".",".",  ".","6",".",  ".",".","3"],
     * ["4",".",".",  "8",".","3",  ".",".","1"],
     * ["7",".",".",  ".","2",".",  ".",".","6"],
     * <p>
     * [".","6",".",  ".",".",".",  "2","8","."],
     * [".",".",".",  "4","1","9",  ".",".","5"],
     * [".",".",".",  ".","8",".",  ".","7","9"],
     * ]
     * 输出: false
     */
    public boolean isValidSudoku(char[][] board) {
        return false;
    }

    /**
     * leetCode.48
     * 给定一个 n × n 的二维矩阵 matrix 表示一个图像. 请你将图像顺时针旋转 90 度
     * <p>
     * 输入: matrix = [[1,2,3],[4,5,6],[7,8,9]]
     * 输出: [[7,4,1],[8,5,2],[9,6,3]]
     * <p>
     * 输入: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
     * 输出: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
     */
    public void rotate(int[][] matrix) {

    }

}
